Secure Peer-to-Peer Chat System - Implementation Plan

ğŸ“Œ Overview

The goal is to create a decentralized, end-to-end encrypted (E2EE) messaging system that does not rely on central servers, ensuring user anonymity and resilience against surveillance.

ğŸ› ï¸ Key Features & Security Measures

âœ… No Central Servers â€“ Messages are relayed peer-to-peer (P2P) for security.
âœ… End-to-End Encryption (E2EE) â€“ Using AES-256 + Diffie-Hellman Key Exchange.
âœ… Identity Protection â€“ Anonymous user verification via cryptographic keys.
âœ… Self-Destructing Messages â€“ Messages auto-delete based on time or read status.
âœ… Offline Messaging Support â€“ Messages can be stored and relayed later.
âœ… Decentralized Hosting â€“ Using IPFS, Tor, or I2P for secure data relays.

ğŸ“Œ Diffie-Hellman Key Exchange (DHKE) Implementation

How It Works:

Each user generates a private and public key.

Users exchange public keys.

Each user computes a shared secret key.

This shared key is used for encrypting messages with AES-256.

Python Implementation:
import secrets
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import os

# Generate a 2048-bit prime for Diffie-Hellman key exchange
parameters = dh.generate_parameters(generator=2, key_size=2048)

# User A (Alice) generates a private and public key
private_key_A = parameters.generate_private_key()
public_key_A = private_key_A.public_key()

# User B (Bob) generates a private and public key
private_key_B = parameters.generate_private_key()
public_key_B = private_key_B.public_key()

# Exchange public keys and compute shared secret
shared_key_A = private_key_A.exchange(public_key_B)
shared_key_B = private_key_B.exchange(public_key_A)

assert shared_key_A == shared_key_B  # Verify both computed the same key

# Convert shared key to a usable format (hashing to derive AES key)
hkdf = HKDF(algorithm=hashes.SHA256(), length=32, salt=None, info=b'peer-to-peer chat')
derived_key = hkdf.derive(shared_key_A)

print(f"Derived AES Encryption Key: {derived_key.hex()}")  # This key will be used for encrypting messages

# AES-256 Encryption Implementation

def encrypt_message(message, key):
    iv = os.urandom(16)  # Generate a random IV
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
    encryptor = cipher.encryptor()
    
    # Ensure message is a multiple of 16 bytes (AES block size)
    padded_message = message.ljust(16 * ((len(message) // 16) + 1), ' ')
    ciphertext = encryptor.update(padded_message.encode()) + encryptor.finalize()
    
    return iv + ciphertext  # Return IV + encrypted message

def decrypt_message(encrypted_message, key):
    iv = encrypted_message[:16]  # Extract IV
    ciphertext = encrypted_message[16:]
    
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
    decryptor = cipher.decryptor()
    
    decrypted_message = decryptor.update(ciphertext) + decryptor.finalize()
    return decrypted_message.strip().decode()

# Example usage
encrypted = encrypt_message("Hello, this is a secure message!", derived_key)
decrypted = decrypt_message(encrypted, derived_key)
print(f"Decrypted Message: {decrypted}")

ğŸ“Œ Tor Integration for Anonymous Messaging Transport

To ensure secure and untraceable message delivery, we will integrate Tor hidden services into the system.

1ï¸âƒ£ Tor Hidden Services Implementation

âœ” Messages are routed through multiple encrypted Tor nodes.âœ” Sender and recipient remain completely anonymous.âœ” Uses the stem Python library to communicate with the Tor network.

Python Implementation (Basic Tor Setup):
from stem.control import Controller
import socket

def start_tor_hidden_service():
    with Controller.from_port(port=9051) as controller:
        controller.authenticate()
        hidden_service = controller.create_ephemeral_hidden_service({80: 5000}, await_publication=True)
        print(f"Tor Hidden Service Running: {hidden_service.service_id}.onion")
        return hidden_service.service_id

# Example usage
tor_address = start_tor_hidden_service()
print(f"Your chat server is accessible at {tor_address}.onion")
2ï¸âƒ£ Message Routing Through Tor

âœ” Messages will be routed via onion services for maximum anonymity.
âœ” No direct IP exposure for senders or receivers.
âœ” Can be combined with P2P messaging over Tor hidden services.

ğŸ“Œ Next Steps

1ï¸âƒ£ Fully integrate Tor transport into messaging system â€“ Encrypt and relay messages through the Tor network.2ï¸âƒ£ Develop a lightweight Tor client for message relaying â€“ Ensure seamless connectivity.3ï¸âƒ£ Test real-world latency and security of Tor-based transport.
