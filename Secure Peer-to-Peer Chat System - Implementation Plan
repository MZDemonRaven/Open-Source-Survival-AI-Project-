Secure Peer-to-Peer Chat System - Implementation Plan

ğŸ“Œ Overview

The goal is to create a decentralized, end-to-end encrypted (E2EE) messaging system that does not rely on central servers, ensuring user anonymity and resilience against surveillance.

ğŸ› ï¸ Key Features & Security Measures

âœ… No Central Servers â€“ Messages are relayed peer-to-peer (P2P) for security.
âœ… End-to-End Encryption (E2EE) â€“ Using AES-256 + Diffie-Hellman Key Exchange.
âœ… Identity Protection â€“ Anonymous user verification via cryptographic keys.
âœ… Self-Destructing Messages â€“ Messages auto-delete based on time or read status.
âœ… Offline Messaging Support â€“ Messages can be stored and relayed later.
âœ… Decentralized Hosting â€“ Using IPFS, Tor, or I2P for secure data relays.

ğŸ“Œ Diffie-Hellman Key Exchange (DHKE) Implementation

How It Works:

Each user generates a private and public key.

Users exchange public keys.

Each user computes a shared secret key.

This shared key is used for encrypting messages with AES-256.

Python Implementation:
import secrets
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import os

# Generate a 2048-bit prime for Diffie-Hellman key exchange
parameters = dh.generate_parameters(generator=2, key_size=2048)

# User A (Alice) generates a private and public key
private_key_A = parameters.generate_private_key()
public_key_A = private_key_A.public_key()

# User B (Bob) generates a private and public key
private_key_B = parameters.generate_private_key()
public_key_B = private_key_B.public_key()

# Exchange public keys and compute shared secret
shared_key_A = private_key_A.exchange(public_key_B)
shared_key_B = private_key_B.exchange(public_key_A)

assert shared_key_A == shared_key_B  # Verify both computed the same key

# Convert shared key to a usable format (hashing to derive AES key)
hkdf = HKDF(algorithm=hashes.SHA256(), length=32, salt=None, info=b'peer-to-peer chat')
derived_key = hkdf.derive(shared_key_A)

print(f"Derived AES Encryption Key: {derived_key.hex()}")  # This key will be used for encrypting messages

# AES-256 Encryption Implementation

def encrypt_message(message, key):
    iv = os.urandom(16)  # Generate a random IV
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
    encryptor = cipher.encryptor()
    
    # Ensure message is a multiple of 16 bytes (AES block size)
    padded_message = message.ljust(16 * ((len(message) // 16) + 1), ' ')
    ciphertext = encryptor.update(padded_message.encode()) + encryptor.finalize()
    
    return iv + ciphertext  # Return IV + encrypted message

def decrypt_message(encrypted_message, key):
    iv = encrypted_message[:16]  # Extract IV
    ciphertext = encrypted_message[16:]
    
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
    decryptor = cipher.decryptor()
    
    decrypted_message = decryptor.update(ciphertext) + decryptor.finalize()
    return decrypted_message.strip().decode()

# Example usage
encrypted = encrypt_message("Hello, this is a secure message!", derived_key)
decrypted = decrypt_message(encrypted, derived_key)
print(f"Decrypted Message: {decrypted}")
ğŸ“Œ Tor Integration for Anonymous Messaging Transport

To ensure secure and untraceable message delivery, we will integrate Tor hidden services into the system.

1ï¸âƒ£ Full Tor-Based Message Relay System

âœ” Messages are sent through onion services instead of the regular internet.âœ” Each peer in the network hosts a hidden service endpoint for messaging.âœ” Uses asynchronous relaying to avoid direct connections.

Python Implementation (Tor Message Relay):
from stem.control import Controller
import socket

def start_tor_hidden_service():
    with Controller.from_port(port=9051) as controller:
        controller.authenticate()
        hidden_service = controller.create_ephemeral_hidden_service({80: 5000}, await_publication=True)
        print(f"Tor Hidden Service Running: {hidden_service.service_id}.onion")
        return hidden_service.service_id

def send_tor_message(message, target_onion):
    try:
        with socket.create_connection((target_onion, 5000)) as sock:
            sock.sendall(message.encode())
            response = sock.recv(1024)
            print("Received response:", response.decode())
    except Exception as e:
        print("Error sending message:", str(e))

# Example usage
tor_address = start_tor_hidden_service()
print(f"Your chat server is accessible at {tor_address}.onion")

2ï¸âƒ£ Ensuring Seamless Tor Connectivity

âœ” Users automatically connect to Tor on startup.âœ” Implementing a Tor bootstrap check to ensure connectivity.

3ï¸âƒ£ Secure Message Transmission Testing

âœ” Validate latency, reliability, and encryption integrity of Tor message relay.âœ” Ensure messages are fully encrypted before transmission.
ğŸ“Œ Next Steps

1ï¸âƒ£ Finalize Tor Message Relay â€“ Securely encrypt and relay messages over onion services.2ï¸âƒ£ Develop a Lightweight Tor Client â€“ Ensure seamless connection and integration.3ï¸âƒ£ Test & Optimize Tor-Based P2P Messaging â€“ Improve performance and reliability.
